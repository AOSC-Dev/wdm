diff -Ncr xdm/verify.c xdm-pam/verify.c
*** xdm/verify.c	Tue May 27 10:22:28 1997
--- xdm-pam/verify.c	Tue Jan 23 14:54:49 2001
***************
*** 41,46 ****
--- 41,49 ----
  
  # include	"dm.h"
  # include	<pwd.h>
+ #ifdef USE_PAM
+ # include	<security/pam_appl.h>
+ #else /* ! USE_PAM */
  #ifdef USESHADOW
  # include	<shadow.h>
  #if defined(SHADOWSUITE) && defined(linux)
***************
*** 51,56 ****
--- 54,60 ----
  extern int errno;
  #endif
  #endif
+ #endif /* USE_PAM */
  
  # include	"greet.h"
  
***************
*** 104,109 ****
--- 108,158 ----
      return env;
  }
  
+ #ifdef USE_PAM
+ static char *PAM_password;
+ pam_handle_t *pamh;
+ static int pam_error;
+ 
+ static int PAM_conv (int num_msg,
+ 		     const struct pam_message **msg,
+ 		     struct pam_response **resp,
+ 		     void *appdata_ptr) {
+ 	int replies = 0;
+ 	struct pam_response *reply = NULL;
+ 
+ 	reply = malloc(sizeof(struct pam_response));
+ 	if (!reply) return PAM_CONV_ERR;
+ 	#define COPY_STRING(s) (s) ? strdup(s) : NULL
+ 
+ 	for (replies = 0; replies < num_msg; replies++) {
+ 		switch (msg[replies]->msg_style) {
+ 		case PAM_PROMPT_ECHO_OFF:
+ 			/* wants password */
+ 			reply[replies].resp_retcode = PAM_SUCCESS;
+ 			reply[replies].resp = COPY_STRING(PAM_password);
+ 			break;
+ 		case PAM_TEXT_INFO:
+ 			/* ignore the informational mesage */
+ 			break;
+ 		case PAM_PROMPT_ECHO_ON:
+ 			/* user name given to PAM already */
+ 			/* fall through */
+ 		default:
+ 			/* unknown or PAM_ERROR_MSG */
+ 			free (reply);
+ 			return PAM_CONV_ERR;
+ 		}
+ 	}
+ 	*resp = reply;
+ 	return PAM_SUCCESS;
+ }
+ 
+ static struct pam_conv PAM_conversation = {
+ 	&PAM_conv,
+ 	NULL
+ };
+ #endif
+ 
  int
  Verify (d, greet, verify)
  struct display		*d;
***************
*** 114,120 ****
  #ifdef USESHADOW
  	struct spwd	*sp;
  #endif
! 	char		*user_pass;
  #if !defined(SVR4) || !defined(GREET_LIB) /* shared lib decls handle this */
  	char		*crypt ();
  	char		**systemEnv (), **parseArgs ();
--- 163,169 ----
  #ifdef USESHADOW
  	struct spwd	*sp;
  #endif
! 	char		*user_pass = NULL;
  #if !defined(SVR4) || !defined(GREET_LIB) /* shared lib decls handle this */
  	char		*crypt ();
  	char		**systemEnv (), **parseArgs ();
***************
*** 124,145 ****
  
  	Debug ("Verify %s ...\n", greet->name);
  	p = getpwnam (greet->name);
  	if (!p || strlen (greet->name) == 0) {
  		Debug ("getpwnam() failed.\n");
  		bzero(greet->password, strlen(greet->password));
  		return 0;
  	} else {
  	    user_pass = p->pw_passwd;
  	}
  #ifdef USESHADOW
  	errno = 0;
  	sp = getspnam(greet->name);
! 	if (sp == NULL) {
! 	    Debug ("getspnam() failed, errno=%d.  Are you root?\n", errno);
  	} else {
! 	    user_pass = sp->sp_pwdp;
  	}
- 	endspent();
  #endif
  #if defined(ultrix) || defined(__ultrix__)
  	if (authenticate_user(p, greet->password, NULL) < 0)
--- 173,208 ----
  
  	Debug ("Verify %s ...\n", greet->name);
  	p = getpwnam (greet->name);
+ 	endpwent();
+ 
  	if (!p || strlen (greet->name) == 0) {
  		Debug ("getpwnam() failed.\n");
  		bzero(greet->password, strlen(greet->password));
  		return 0;
+ #ifndef USESHADOW
  	} else {
  	    user_pass = p->pw_passwd;
+ #endif
  	}
+ #ifndef USE_PAM
  #ifdef USESHADOW
  	errno = 0;
  	sp = getspnam(greet->name);
! #if !(defined(__QNX__) && !defined(__QNXNTO__))
!   	endspent();
! #endif  /* QNX doesn't use endspent() to end shadow passwd ops */
! 
! 	if (sp) {
! 	    user_pass = sp->sp_pwdp;		/* local shadow file	*/
  	} else {
! 	    user_pass = p->pw_passwd;		/* NIS expanded passwd? */
! 	}
! 
! 	if (!user_pass) {			/* should not happen	*/
! 	    Debug ("getspnam() failed, errno=%d.  Are you root?\n", errno);
! 	    bzero(greet->password, strlen(greet->password));
! 	    return 0;
  	}
  #endif
  #if defined(ultrix) || defined(__ultrix__)
  	if (authenticate_user(p, greet->password, NULL) < 0)
***************
*** 153,162 ****
  			return 0;
  		} /* else: null passwd okay */
  	}
! 	Debug ("verify succeeded\n");
! 	bzero(user_pass, strlen(user_pass)); /* in case shadow password */
  	/* The password is passed to StartClient() for use by user-based
  	   authorization schemes.  It is zeroed there. */
  	verify->uid = p->pw_uid;
  	verify->gid = p->pw_gid;
  	home = p->pw_dir;
--- 216,256 ----
  			return 0;
  		} /* else: null passwd okay */
  	}
! 
! 	/* If the encrypted password begins with a "!", the account
! 	   is locked and the user cannot login, even if they have
! 	   been "pre-authenticated." */
! 
! 	if (p->pw_passwd[0] == '!' || p->pw_passwd[0] == '*') {
! 	  Debug ("The account is locked, no login allowed.\n");
! 	  bzero(user_pass, strlen(user_pass));	     /* in case shadow password */
! 	  bzero(greet->password, strlen(greet->password)); /* clear plain password    */
! 	  return 0;
! 	}
! 
  	/* The password is passed to StartClient() for use by user-based
  	   authorization schemes.  It is zeroed there. */
+ 	bzero(user_pass, strlen(user_pass)); /* in case shadow password */
+ 
+ #else /* USE_PAM */
+ 	#define PAM_BAIL if (pam_error != PAM_SUCCESS) { \
+ 	   pam_end(pamh, 0); return 0; \
+ 	 }
+ 	PAM_password = greet->password;
+ 	pam_error = pam_start("wdm", p->pw_name, &PAM_conversation, &pamh);
+ 	PAM_BAIL;
+ 	pam_error = pam_set_item(pamh, PAM_TTY, d->name);
+ 	PAM_BAIL;
+ 	pam_error = pam_authenticate(pamh, 0);
+ 	PAM_BAIL;
+ 	pam_error = pam_acct_mgmt(pamh, 0);
+ 	/* really should do password changing, but it doesn't fit well */
+ 	PAM_BAIL;
+ 	pam_error = pam_setcred(pamh, 0);
+ 	PAM_BAIL;
+ #endif /* USE_PAM */
+ 	Debug ("verify succeeded\n");
+ 
  	verify->uid = p->pw_uid;
  	verify->gid = p->pw_gid;
  	home = p->pw_dir;
diff -Ncr xdm/session.c xdm-pam/session.c
*** xdm/session.c	Mon Mar  2 14:56:36 1998
--- xdm-pam/session.c	Tue Jan 23 14:55:27 2001
***************
*** 55,60 ****
--- 55,66 ----
  #ifdef K5AUTH
  # include <krb5/krb5.h>
  #endif
+ #ifdef USE_PAM
+ # include <security/pam_appl.h>
+ #endif
+ #ifdef USESHADOW
+ # include <shadow.h>
+ #endif
  
  #ifndef GREET_USER_STATIC
  #include <dlfcn.h>
***************
*** 141,146 ****
--- 147,156 ----
  
  static Jmp_buf	abortSession;
  
+ #ifdef USE_PAM
+ extern pam_handle_t *pamh;
+ #endif
+ 
  /* ARGSUSED */
  static SIGVAL
  catchTerm (n)
***************
*** 448,453 ****
--- 458,471 ----
  SessionExit (d, status, removeAuth)
      struct display  *d;
  {
+ #ifdef USE_PAM
+     if (pamh) {
+ 	/* shutdown PAM session */
+ 	pam_close_session(pamh, 0);
+ 	pam_end(pamh, PAM_SUCCESS);
+ 	pamh = NULL;
+     }
+ #endif
      /* make sure the server gets reset after the session is over */
      if (d->serverPid >= 2 && d->resetSignal)
  	kill (d->serverPid, d->resetSignal);
***************
*** 513,523 ****
  		Debug ("%s ", *f);
  	Debug ("\n");
      }
      switch (pid = fork ()) {
      case 0:
  	CleanUpChild ();
  
! 	/* Do system-dependent login setup here */
  
  #ifndef AIXV3
  #ifndef HAS_SETUSERCONTEXT
--- 531,558 ----
  		Debug ("%s ", *f);
  	Debug ("\n");
      }
+ #ifdef USE_PAM
+     if (pamh) pam_open_session(pamh, 0);
+ #endif    
      switch (pid = fork ()) {
      case 0:
  	CleanUpChild ();
+ #ifdef XDMCP
+ 	/* The chooser socket is not closed by CleanUpChild() */
+ 	DestroyWellKnownSockets();
+ #endif
  
! #ifdef USE_PAM
!     /* pass in environment variables set by libpam and modules it called */
!         if (pamh) {
!           long i;
!           char **pam_env = pam_getenvlist(pamh);
!           for(i = 0; pam_env && pam_env[i]; i++)
!             {
!               verify->userEnviron = putEnv(pam_env[i], verify->userEnviron);
!             }
!         }
! #endif
  
  #ifndef AIXV3
  #ifndef HAS_SETUSERCONTEXT
diff -Ncr xdm/util.c xdm-pam/util.c
*** xdm/util.c	Thu Oct  3 12:49:48 1996
--- xdm-pam/util.c	Tue Jan 23 14:54:49 2001
***************
*** 141,146 ****
--- 141,172 ----
  	return new;
  }
  
+ char **
+ putEnv(string, env)
+      const char *string;
+      char ** env;
+ {
+   char *v, *b, *n;
+   int nl;
+   
+   if ((b = strchr(string, '=')) == NULL) return NULL;
+   v = b + 1;
+   
+   nl = b - string;
+   if ((n = malloc(nl + 1)) == NULL)
+     {
+       LogOutOfMem ("putAllEnv");
+       return NULL;
+     }
+   
+   strncpy(n, string,nl + 1);
+   n[nl] = 0;
+   
+   env = setEnv(env,n,v);
+   free(n);
+   return env;
+ }
+ 
  freeEnv (env)
      char    **env;
  {
